R2 is character to render
ER0 is where to render

0x2d56
R0 character to render
ER6 is where to render?
ER2 is buffer to render into

##### 8b11 == 6
R0 = R0 + 0x30
R8 = R0
R0 >>= 1
ER0 *= 5
ER0 += 0694h
EA = ER0

R9 = 5


#### 8b11 == 7
lea 400
R8 = 6

if R0 < 0x20
	lea 0746
	r0 += 31
	r8 += 1
end

if r0 == 7c # This seems to be a check if it's the fill character


R0 += e0
ER0 = R0 * 5
R4 = ER0 & 7
ER0 >>= 3
ER0 = R0 * R8

ea += ER0

R0 = [EA+]

R0 <<= R4
R0 >>= 1

R1 = 8 - R4

if R1 < 5
	r9 = 0
	er6 = ea + r8 - 1
	r1 = [er6]
	r6 = 9 - r4
	r1 >>= r6
	r0 |= r1
end

r0 &= 7c
[er2] = r0
r2++
ea++
r5--


###########
fcn.00002ec2

er10 is 87d0 or f800, which is buffer vs real screen
switches based on 811d

r8 is either 0xC or 0x10 based on if buffer or real screen

if r1.7
  r1 = ~r1
  er8 = r8 * r1
  er10 -= er8
else
  er8 = r8 * r1
  er10 += er8
end

r1 = 0
r2 = r0
r2 &= 0b111

er10 += er0
[ea] = er10
r0 = r2


Calculates the address of the start of the row
takes into account if writing to real screen or buffer
since real screen has 4 unused bytes for every row

not sure what r0 output is yet, just lowest 3 bits of R0?

er2 is the address where the result will be stored
r1 is the character offset, in one's complement?

########

fcn.00002e28
er0 = address to write to
er2 = character

ea = er0
r0 = [er2]
r1 = sp + 2

if r1 != 0
	r0 &= r1	Some kind of bitmask?
end

er14 = er0

switch [811c]
00:
	r0 = r15
	r0 ^= 0xFF
	r1 = [ea]
	r0 &= r1
	r0 |= r14
01:
	
02:

03:

04:
